#### 缓存雪崩

##### 定义

是指缓存大面积失效，所有的请求都落在了数据库上，造成数据库短时间内承受大量请求崩坏。

##### 出现场景

1.服务刚刚启动，缓存中的值为空，所有的请求都向数据库查询。

2.缓存大面积时间到期，导致缓存失效。

3.缓存层挂掉，所有请求直接打到数据库上。

##### 解决方案

1. 缓存中的过期时间设置随机，防止同一时间大面积失效。
2. 缓存预热，在应用启动的过程中，首先队缓存初始化，将数据库中的数据加入到缓存中。
3. 互斥锁，大量的请求落在某个key上的时候，通过锁同步执行。

#### 缓存穿透

##### 定义

缓存穿透指缓存和数据库中都没有数据，导致所有的请求都落在数据库中，造成数据库的短时间承受大量的请求而崩溃。

##### 场景

1. 一种攻击手段，攻击人使用该特性，制造大量的请求。

##### 解决方案

1. 在接口层进行基础的校验，比如用于鉴权校验，id的基础校验。
2. 如果数据在数据库中没有取到，缓存中也没有取到，就将该数据存储在缓存中，并设置短暂的过期时间。防止攻击用户反复使用同一个id暴力攻击。
3. 采用布隆过滤器，将可能存在的数据放在一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截，从而避免对数据库造成压力。（如果有一个是0，则不存在。如果都是1，可能存在）使用布隆过滤器当缓存的索引，只有在布隆过滤器中有，才去查询缓存，如果缓存中没有查询到数据，到db查询，如果布隆过滤器中都没有该元素，直接返回。

#### 缓存击穿

##### 定义

缓存中没有数据，但是数据库中有数据（一般是缓存时间过期），由于并发用户特别多，同时读缓存没有读到，同时到数据库中取数据，引起数据库压力大。和缓存雪崩不同的是缓存击穿是并发的访问同一个数据，而缓存雪崩是不同的数据都过期了，很多的数据在缓存中都查不到。（高并发）

##### 解决方案

1. 设置热点数据永不过期
2. 加互斥锁

#### 分布式系统中，常用的缓存方案

1. 客户端缓存：APP缓存，网页缓存
2. CDN缓存
3. 服务端缓存：内部缓存（比如Java容器），外部缓存（Redis做缓存）
4. 数据库缓存：持久层缓存（mybatis）、mysql缓存

#### 缓存的过期删除策略

##### 分类

1. 定时删除：
2. 惰性删除：
3. 定期删除：

##### 优缺点



##### Redis中使用的策略

#### 如何保证数据库与缓存的一致性

一般用于写操作。缓存和数据库是分开的。无法做到原子性。有可能缓存更新失败，或者数据库更新失败。

##### 解决方案一 先删除缓存，再更新数据库

![img](https://i.loli.net/2021/04/16/12naoQhM8cWLpVY.jpg)

读操作：首先去缓存中查询，如果缓存中存在，直接返回。

写操作：首先删除缓存，更新完数据之后，异步的刷新缓存。

###### 优点

1. 操作简单。
2. 缓存使用的是删除的策略，如果是更新缓存，在更新数据库。如果数据库中的操作失败，那么数据库和缓存中的数据就会出现不一致问题。如果流程：先不删缓存，再更新数据库，再更新缓存。如果更新DB成功，缓存失败，就会造成读取缓存都是旧的数据。

###### 缺点

1. 再每一步都有可能出问题，比如，删除缓存失败，流程该如何走，异步返回失败，缓存如何做。
2. 并发情况下，出现数据不一致。并发的写写操作，A先更新数据，B也更新数据，但是异步通知的时候，由于网络原因，后更新的数据先辈更新到缓存中。

###### 适用场景：数据一致性不高的情况。

##### 解决方案二 保证数据最终的一致性

让缓存去监听数据库的binlog日志，如果数据库操作失败，我们可以使用binlog日志重新获取最新的消息，再次刷新缓存。

写流程：先删除缓存，删除以后去更新数据库，监听DB的binlog日志，通过分析binlog来更新缓存。

读操作：如果缓存没有读到，就去DB中去读，之后异步刷新回内存。

为什么要是删除而不是更新？

删除更加轻量级 ，如果使用修改，可能会涉及到很多的数据修改，同时更新有可能有更新失败的情况。

##### 如果数据一致性要求高的情况下，如何保证数据一致性问题

我们将读数据库和写缓存串行化，