### CAP理论

在分布式系统中，一定存在分区容错性的存在。其次就是一致性、可用性。

**一致性**：多个数据副本可以保证一致的特性。在一致性的条件之下，系统在执行更新的操作之后，可以从一个一致性状态到另一个一致性状态。对系统的一个数据更新成功之后，所有的用户都要读到最新的值。

**可用性：**分布式系统可以面对各种异常时提供正常的服务的能力，只要用户收到请求，就必须给出响应。

**分区容错性：**大部分分布式系统都是分布在不同的子网之中，每个子网都是一个区。分区容错说的是区间之间的通信是有可能失败的。一般来说，分区容错是无法避免的，可以认为CAP中P总是成立的。

### 为何一致性和可用性不可以同时成立？

由于分区一致性是一直都是存在的，所以当满足一致性的时候，A和B都存储了变量v=0,如果A系统要对这个变量进行修改，要保证数据的一致性，在A进行写操作的时候，必须锁定B的读写，这时候不满足可用性。如果保证可用性，就不能满足一致性。

### 一致性算法

为解决数据一致性问题，在不断的演变中，提出了一系列的算法。有两阶段提交2PC、三阶段提交3PC、Paxos算法。

秒杀系统订单和积分系统，如何保证两边的数据一致性？

#### 2PC（两阶段提交）

2PC是用来保证分布式系统的数据一致性协议。

两阶段提交的问题是保证整个服务的原子性。在服务的调用链路中，我们所有的服务数据要么都成功，要么都失败。

##### 2PC的过程

在两阶段提交的过程中，主要涉及的两种角色，分别是协调者和参与者。

第一阶段：在执行一个分布式事务的时候，事务的发起者首先会向协调者prepare请求，告诉需要执行哪些事务，执行完毕不要提交，执行完成之后给我回复。参与者接受到消息以后，开始执行事务，并记录日志，之后参与者就会向协调者反馈消息。

第二阶段：协调者根据参与者的反馈情况，是否进行事务的提交。

##### 2PC存在的问题

**单点故障问题：**如果协调者出现问题，整个系统都处于不可用的状态。

**数据不一致问题：**当第二阶段的时候，协调者发送了一部分commit请求就挂了，收到的参与者会进行事务的提交，没有收到的不会进行事务的提交，就会产生数据不一致性问题。

**阻塞问题：**如果参与者发送了prepare请求之后，参与者收到之后就会执行自己的任务，并不提交，如果协调者挂了，这些资源就不会释放，所以，极大的影响性能。

#### 3PC（三阶段提交）

##### 三阶段提交的过程

第一阶段（**CanCommit**）：协调者向参与者发送CanCommit请求，参与者收到请求之后，会根据自身的情况，向协调者返回自身的状态。

第二阶段（**PreCommit**）：协调者根据参与者的返回的响应来决定是否可以进行PreCommit操作。如果上面参与者都返回YES，那么所有的协调者会向参与者发送PreCommit请求。参与者收到预提交请求以后会进行事务的执行操作，并记录日志。最后参与者在执行完任务以后会给协调者返回值。

第三阶段（**DoCommit**）：协调者收到了所有参与者的发送成功完成的请求以后，会向所有参与者发送事务提交的请求。参与者完成后会给协调者返回响应，如果在第二阶段（PreCommit）阶段收到了NO或者一段时间里没有收到所有参与者的响应，就会中断请求发送。

但是如果说在第二阶段的时候，全部的参与者都返回了YES，在第三阶段，参与者没有收到协调者发送的提交事务的请求，他就会在一段时间内进行事务的提交，为什么？因为在第一阶段所有的协调者都返回了可以执行事务的响应，所以我们有理由相信其他的系统都可以进行事务的提交和执行。

##### 3PC在2PC的基础上改进和不足

在2PC的基础上通过超时的机制，缓解了阻塞的问题。

不足：没有解决一致性的根本问题。

在第二阶段，一个参与者接受到消息以后，其他的参与者和协调者挂了，就会导致数据的不一致性。

#### Paxos算法

他解决的问题就是在分布式系统之中，如何就某个值达成一致。运行在允许宕机故障的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。它利用大多数 (Majority) 机制保证了2F+1的容错能力，即2F+1个节点的系统最多允许F个节点同时出现故障。

##### 角色分类

分为三种：提议者 (Proposer)，决策者 (Acceptor)，和最终决策学习者 (Learner)。

1. **Proposer提案者：**提出提案（Proposal）。提案的信息包括提案的编号N和提议的值value。
2. **Acceptor表决者：**参与决策，回应提案者的提案。如果获得可多数表决者的接受，则该提案通过。
3. **Learner**:不参与决策，从Proposers/Acceptor中学习最新的一致性提案。

##### Poxos的过程

分成两个过程：Prepare阶段和accept两个过程

1.Prepare阶段

Proposer提案者：负责提出提案，每个提案者在提出提案的时候，都会获取到一个全局唯一、递增的提案号N。将该提案号发送给所有的表决者，在该阶段只会向表决者发送提案号。

Acceptor表决者：每次表决者在通过某个提案的时候，就会将提案的编号记录在本地，这样每个表决者在通过一个提案的时候，就会存着一个最大的提案。其编号假设是maxN。每个表决者会通过大于自己本地的maxN提案。在批准提案的时候，表决者就会将以前接受过的最大编号的提案作为反馈给提案者。

2.Accept阶段

当提案被提出以后，如果Proposer收到半数的批准。那么此时会向表决者发送真正的提案。会发送提案的内容和提案的编号。

表决者收到提案的请求以后，就会与本身批准过的最大提案编号进行比较，如果该提案大于等于自己所批准过的最大提案号，则就批准该提案（执行提案的内容不提交）。随后将情况返回。

如果提案者收到超过一半的表决者通过，那么他就会向所有的acceptor发送提案的提交请求。在上述的情况下，只有一半的批准了该提案，如果没有批准的表决者发送提案内容和提案编号并无条件的提交。前面已经通过的表决者只需要发送提案号执行提交。

如果没有收到半数的统一，编案号会递增，进入第一准备状态。

![img](https://i.loli.net/2021/04/09/c1a8AQ9fTlIpYxi.png)

##### Poxos的缺点

假如现在有两个提案者P1、P2。在某一时刻。P1提出的M1完成了Prepare阶段，P2 同时也提出了一个方案 M2，它也完成了Prepare 阶段的工作。但是M1比M2的提案号小，所以在第二阶段无法被批准，这时候，他就会自增，生成M3，但是M2提案不能被通过，这就会造成死循环。

#### ZAB协议

`ZAB(ZooKeeper Automic Broadcast)` 原子广播协议，该协议能够很好地支持 **崩溃恢复** 。

##### Zookeeper的角色

三种角色：领导者（Leader）、跟随者（Follower）、观察者（Observer）。

**Leader：**集群中唯一的写请求的处理者，可以发起投票。

**Follower：**可以接受客户端的请求，如果是读请求，可以自己处理，如果是写请求，需要转交给Leader。在选举的过程中，可以参与投票。有选举权和被选举权。

**Observer**：没有选举权和被选举权的跟随者。

##### Zookeeper的服务状态

LOOKING:集群没有Leader，服务会进入LOOKING状态，目的是查找或选举Leader。

FOLLOWING：follower角色

LEADING：leader角色；

OBSERVING：observer角色

##### Zookeeper的Leader选举的过程

###### 什么时候进行？

分为两种情况

1.整个集群服务启动的时候，如果没有Leader就会进入选举状态。

2.就是Leader宕机或其他情况，无法对外部提供服务，因为其他节点通过心跳检测到leader失联之后，集群会进去选举状态。

###### 选举规则

是要通过投票的方式去选举。

投票的规则：

**ZXID：**是一个很重要的概念。他是分成两个部分，epoch和计数器部分，是一个全局有限的数字。epoch的作用是记录集群现在所属的那个Leader。

```java
  /*
         * We return true if one of the following three cases hold:
         * 1- New epoch is higher
         * 2- New epoch is the same as current epoch, but new zxid is higher
         * 3- New epoch is the same as current epoch, new zxid is the same
         *  as current zxid, but server id is higher.
         */

        return ((newEpoch > curEpoch)
                || ((newEpoch == curEpoch)
                    && ((newZxid > curZxid)
                        || ((newZxid == curZxid)
                            && (newId > curId)))));
```

当其他节点的纪元比自身高投它，如果纪元相同比较自身的zxid的大小，选举zxid大的节点，这里的zxid代表节点所提交事务最大的id，zxid越大代表该节点的数据越完整。

最后如果epoch和zxid都相等，则比较服务的serverId，这个Id是配置zookeeper集群所配置的，所以我们配置zookeeper集群的时候可以把服务性能更高的集群的serverId配置大些，让性能好的机器担任leader角色。

###### 选择流程

两种情况，服务启动的时候，与服务未启动Leader节点发生故障。

一、集群启动以后，没有Leader的情况下，所有的Zxid的值为0，比如现在有三台机器，Server1、Server2、Server3。当Server1启动的时候，发现没有Leader，所以他就会投票投自己，投票的内容是（Zxid，myid）,由于初始化所以Zxid都为0，此时server1的投票为1，还不能作为Leader。

接着Server2启动，他会推举自己（2，0）并将投票信息广播，这时，Server1会比较自己的与Server2的Zxid。它发现server2更适合做Leader并会将这个消息广播出去。server2收到以后，且发现自己的投票超过一半，确定Server2为Leader。集群状态也从looking变成正常模式。

当 `server3` 启动发现集群没有处于 `Looking` 状态时，它会直接以 `Follower` 的身份加入集群。

二、Leader节点出现问题的情况。

Follower会将自己的状态从Following变成Looking状态。假如Sever1给自己投票为（1，20），Server3给自己投票（3，10），然后广播给其他的节点，Server1和Server3会收到彼此的消息，会于自身的数值进行比较，最后Server1收到了投票将自己设置成Leader。

##### 消息广播模式

由于只有Leader节点才有写的权限，所以当其他节点有写请求，只能转交给Leader节点处理，同时，如果Leader节点向所有的子节点更新数据，那要保证数据的一致性。

要保证数据的一致性，需要将保证有序性。

ZAB通过TCP协议传输，保证网络传输的有序性；节点都维护了FIFO的队列，保证全局的有序性；通过全局递增的zxid保证因果的有序性。

###### 消息广播的过程

1. Leader收到请求以后，生成一个事务，其中包含zxid。
2. Leader广播该事务，在节点中都维护了一个队列，保证消息发送的顺序性与接受的顺序性。
3. Follwer接受到消息以后，将事务写回自己的磁盘，写入成功后，返回给Leader一个ACK。
4. Leader收到过半的ACK之后，开始提交本事务，并广播事务提交信息。

##### 崩溃恢复

崩溃分为两种，Leader崩溃与Follower崩溃。

Follower：