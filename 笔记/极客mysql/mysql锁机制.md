根据加锁的范围，mysql里面的锁大致可以分为全局锁、表级锁、行锁三种。

## 全局锁

对整个数据库实例加锁。

sql语句

```mysql
Flush tables with read lock
```

使用该命令会使整个数据库处于只读状态。数据库的增删改、数据定义语句和更新事务的更新语句都会被阻塞。

使用场景：全局逻辑备份。

风险：

1. 在主库备份的，在备份期间，业务摇摆。
2. 在从库备份，备份期间不能执行主库同步的bilog，导致主从延迟。

如果要全库只读，为什么不使用set global readonly=true的方式？

1. 在有的库中readonly用于做其他判断，比如判断主备库，所以修改global变量的方式影响太大。
2. 在异常处理机制上有区别，如果使用flush命令之后客户端发生异常断开，那么mysql就会自动释放这个全局锁，整个库会回归到正常更新的状态，如果将整个库设置成readonly的时候，如果客户端发生异常，整个数据库一直会保持readonly状态，这会让整个数据库长期处于不可写状态，风险很高。

## 表级锁

表级锁分为表锁和元数据锁(meta data lock,MDL)

### 表锁

语法

```mysql
lock tables …read/write		
```

释放锁

```mysql
unlock tables
```

和使用全局锁一样，使用表锁可以手动释放，也可以在客户端断开的时候自动释放。lock tables语法除了会限制别的线程读写外，还会限制本线程的操作。

对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。

### 元数据锁（MDL） 

MDL是不需要手动增加的。

在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。

- 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
- 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

### 行锁

不是每个数据库引擎都支持行锁，比如MyISAM引擎就不支持行锁，不支持行锁，就意味着在控制并发的时候，只能使用表锁，在同一时间里，同一张表只能执行一个更新操作。

#### 两阶段锁

在InnoDB中，行锁在需要的时候才加，但并不是不需要就立刻释放，而是等到事务结束时才释放。这就是两阶段锁。

根据两阶段锁的机制，**我们在事务中，要把可能造成锁冲突、最可能影响并发的锁尽量放后面。**

#### 死锁和死锁检测

死锁的概念是什么? 举例说明出现死锁的情况.

在并发系统中，不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源，就会导致这几个线程都进去无限等待的状态。

<div align="center"> <img src="png/1.png"/> </div><br>

上面这个图中，事务A等待事务B释放id=2的行锁，事务B等待事务A释放id=1的行锁。事务A和事务B都在相互等待对方释放资源，进入死锁状态.

##### 解决死锁的两种策略

1. 进行等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。
2. 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。

##### 等待超时处理死锁的机制什么?有什么局限?

在InnoDB中，将innodb_lock_wait_timeout的默认值设置成50s，这意味着，当发生死锁的时候，要等待很长时间，然后才可以继续进行。如果时间设置的太小的话，如果只是一个简单的锁等待，这样就会出现误伤。

##### 死锁检测处理死锁的机制是什么? 有什么局限?

在发生死锁的时候主动检测，可以快速的发现并处理。在死锁检测的过程中，当一个事务发生死锁的时候，就要看她所依赖的线程有没有被人锁住，如此判断是否发生了死锁。在每一个新来被堵住的线程都要进行检测，当数据量比较大的时候，就会造成CPU的大量消耗。

##### 怎么解决由这种热点行更新导致的性能问题呢？

1. 一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。
2. 控制并发度。