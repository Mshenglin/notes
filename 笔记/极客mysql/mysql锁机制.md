根据加锁的范围，mysql里面的锁大致可以分为全局锁、表级锁、行锁三种。

## 全局锁

对整个数据库实例加锁。

sql语句

```mysql
Flush tables with read lock
```

使用该命令会使整个数据库处于只读状态。数据库的增删改、数据定义语句和更新事务的更新语句都会被阻塞。

使用场景：全局逻辑备份。

风险：

1. 在主库备份的，在备份期间，业务摇摆。
2. 在从库备份，备份期间不能执行主库同步的bilog，导致主从延迟。

如果要全库只读，为什么不使用set global readonly=true的方式？

1. 在有的库中readonly用于做其他判断，比如判断主备库，所以修改global变量的方式影响太大。
2. 在异常处理机制上有区别，如果使用flush命令之后客户端发生异常断开，那么mysql就会自动释放这个全局锁，整个库会回归到正常更新的状态，如果将整个库设置成readonly的时候，如果客户端发生异常，整个数据库一直会保持readonly状态，这会让整个数据库长期处于不可写状态，风险很高。

## 表级锁

表级锁分为表锁和元数据锁(meta data lock,MDL)

### 表锁

语法

```mysql
lock tables …read/write		
```

释放锁

```mysql
unlock tables
```

和使用全局锁一样，使用表锁可以手动释放，也可以在客户端断开的时候自动释放。lock tables语法除了会限制别的线程读写外，还会限制本线程的操作。

对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。

### 元数据锁（MDL） 

MDL是不需要手动增加的。

在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。

- 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
- 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。