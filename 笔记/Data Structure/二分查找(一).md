#### 概述

二分查找又称为折半查找，通过每次元素的对比将待查找的区间缩小一半，直到将区间缩小到一为止。

#### 最基本的二分查找

数组a[]=[2,3,4,5,7,9,11,15,18]找出其中值等于15的元素

##### 思路一

在实现这个问题上，我们可以通过遍历该数组中的所有元素，如果找到，则返回该元素的下标，如果没有返回-1。

##### 思路二

通过二分查找将每次缩小区间，直到找到该元素。

##### 对比

如果我们通过遍历该数组来查找元素，可以得出时间复杂度为O(n),通过二分查找时间复杂度为O(logn).(稍后将会分析)

不难看出二分查找的效率是非常高效，举个例子，加入现在有十万条数据，通过遍历，最坏的情况下，我们需要遍历十万次，但是通过二分查找，最多需要进行4次查找就可以结束。

##### 二分查找的实现

###### 代码实现

通过下面一段代码就可以实现最基本的二分查找算法。

```java
//a为所要查找的数组，n为数组的长度，num是所要找的数值
private  static  int bsearch(int[] a,int n,int num) {
	//右边界
    int r=n-1;
    //左边界
     int l=0;
    //终止条件
     while (l<=r) {
         //中间值
         int mid=(r+l)>>>1;
         //如果元素与目标元素相同，则返回该元素的下标
         if (num==a[mid]) {
             return mid;
         }
         //目标元素比中间的元素大，缩小右边界
         else if(num<a[mid]) {
             r=mid-1;
         }
         //目标元素比中间的元素大小，缩小左边界
         else {
             l=mid+1;
         }
     }
    //如果没有查找到，返回-1
     return -1;
    }q
```

###### 核心步骤

**循环的终止** 

```java
 while (l<=r)
```

l<=r,不是l<r.(只是在这个算法中，如果终止条件为l<r,则要改变其他条件，这里不展开)

**mid的取值**

```java
mid=(r+l)>>>1
```

最基本的写法为mid=(r+l)/2,但是这是有问题的，如果r和l很大的时候，就会造成整型溢出，所以对其进行改进为mid=l+(r-l)/2,在计算机位运算会执行效率更高，所以可以写为l+((r-l)>>1)  ，为了考虑到负数的情况，所以使用无符号右移运算符(>>>)

**左边界和有边界的更新**

左边界为l=mid+1，右边界为r=mid-1.不可以将边界写为l=mid，r=mid这样就会造成死循环。

###### 算法分析

上面说到二分查找的时间复杂度为O(log n)，下面就对时间复杂度进行证明。

假设数据量为n，在其中使用二分查找查找相对应的元素，则被查找的区间变化规律为

**n，n/2，n/4，n/8，n/16……n/(2<sup>k</sup>) **

当区间缩小到1时，即n/(2<sup>k</sup>)=1，k=log <sub>2</sub> n,所以二分查找的时间复杂度为O(log n)

##### 二分查找的应用场景

1. 二分查找需要支持随机访问。所以二分查找一般是使用在数组中，数组的随机访问的时间复杂度为O(1),链表的随机访问时间复杂度为O(n),如果对链表使用二分查找，二分查找的时间复杂度会更高。

2. 二分查找对数组中的数据需要是有序的。使用二分查找需要对元素进行比比较，然后缩小区间。

3. 二分查找适合于数据量比较大的情况，在数据量较小的情况下，使用普通的遍历和二分查找性能相差不大，只有数据量大的时候才可以体现出二分查找的优势。

   