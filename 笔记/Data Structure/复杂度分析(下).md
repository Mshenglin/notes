## 复杂度分析的四个概念

在平时的复杂度分析中，我们会用到以下的四个常用的复杂度分析，下面就对这四个概念进行讲解。

#### 基本概念

1. **最好时间复杂度：**最好情况执行完的时间复杂度。

2. **最坏时间复杂度：**最坏情况执行完的时间复杂度。

3. **平均时间复杂度：**代码在所有情况下执行次数的加权平均值。

4. **均摊时间复杂度**：在代码执行的复杂度中，大多数是复杂度低的情况，个别是复杂度高的情况<u>**且会时序发生**</u>时，可以将高时间复杂度向低时间复杂度均摊，均摊的结果一般为低时间复杂度。

   ------

   

   #### 为什么要提出引入这四个概念？如何去分析复杂度？

   下面就使用例子来进一步讲解这四个概念，以及使用这四个概念。

   ```java
   void find(int m,int[] nums)
   {
        for(int i=0;i<nums.length;i++)
        {
            if(nums[i]==m)
            {
            return num[i];
            }
        }
        return -1;
   }
   ```

   ​		上面的这段代码实现的功能是：从一个数组中，寻找指定的数m相同的元素，如果存在则返回该元素，如果没有返回-1.

   ​		就上面的这段简单的代码，在最好的情况下他的复杂度为O(1),即在第一个位置就寻找到该元素，并返回。在最坏的情况下他的复杂度为O(n),即在遍历完整个数组后找到该元素，或遍历完没有找到该元素。

   ​		以上的两种情况都属于极端的情况，实际中出现的概率非常的小。那该如何正确的表示上面代码的时间复杂度？这时候就要引出平均时间复杂度。

   ​		平均时间复杂度通过概率论中的加权平均值表示。

   ​		就上面这段代码为例，他的平均时间复杂度该如何计算？

   ​		在上面查找一共会有两个结果：查找到和没有查找到。假设查找到和没查找到的概率都为1/2.

   同时，0~n-1这n个位置也是概率也是相同的为1/n.根据概率乘法法则，查找0~n-1位置的概率为1/(2n).

   所以时间复杂度计算如下：
   $$
   1*1/2n+2*1/2n+3*1/2n+……+n*1/2n+n*1/n
   =(3n+1)/4
   $$
   去掉系数以及常量，复杂度的值为：O(n)

   ​		通过上面的分析，在一些程序中使用平均时间复杂度可以更好的描述他的复杂度。

   ​		下面讲解均摊复杂度，相对于上面的知识均摊复杂度更加的特殊，记住以下几点，就可以了。

   - **大多数情况下是复杂度低的操作**
   - **少部分是复杂度高的操作**
   - **时序发生**

   下面通过一个例子来讲解

   ```java
   int[] arr= new int[10];
   int len=10;
   int i=0;
   void add(int element)
   {
   //判断容量是否充足
       if(i>=len)
   	{创建一个新的数组
   	int[] array=new int[len*2];
   	//将旧数组中的数据全部赋值给新数组
   	for(int j=0;j<len;j++)
   	{
   	array[j]=arr[j];
   	}
   	将新数组复制给旧数组
   	arr=array;
   	len=2*len;
   	}
   	//如果数组容量充足，将该数据存入该数组中
   	a[i]=element;
   	//维护i
   	i++;
    }
   ```

   ​		上面的这段程序，我们该如何去计算他的复杂度呢？

   ​		首先，我们进行分析，当数组容量充足时，复杂度为O(1),当要进行扩容操作时，复杂度为O(n).同时高复杂度的情况是时序发生的，根据结论我们可以得到均摊复杂度为O(1).这个我们也可以通过数学期望来完成。

   ### 