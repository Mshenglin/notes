[leetcode](https://leetcode-cn.com/problems/next-greater-element-i/)

### 题目描述

给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。

nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。

```less
示例 1:

输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。
    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。
    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。
示例 2:

输入: nums1 = [2,4], nums2 = [1,2,3,4].
输出: [3,-1]
解释:
    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。
    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。
```

### 解题思路

#### 思路一 暴力遍历

在num2中找到nums1中对应的元素，然后向后遍历，找到第一个大于该值的元素，返回。

使用两个for循环，时间复杂度为O(n²)。

#### 思路二 使用单调栈

单调栈，就是通过自己的处理可以使栈中的元素是单调递增，或者是单调递减的。这道题的解题方法，类似与现实生活中人的高低个子，比如输入一个[2,1,4,3],他可以表示为以下。底个子的视野就会被第一个比他大的挡住，挡住他的元素就是所求元素。

```

							 |________
	 __________________________|	  |
	|		 _________________|	      |	
	|		|				 |      |      
————————————————————————————————————————————————————————————————————————————————————————————
```

我们可以使用单调栈，让栈顶的元素为第一个大于该位置的元素。

代码实现

```java
class Solution {
    //首先使用单调栈将nums2中的数据排列，同时将存入map集合（key=该元素的值，value=该元素所在的下标）中，然后根据nums1中的值在map中找到对应的索引，取出nums2使用单调栈生成结果集的值，返回
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        //存放元素值，和对应的索引值
        HashMap<Integer,Integer> map=new HashMap<>();
        //用于存放nums2的结果集
        int[] allRes=new int[nums2.length];
        //用于存放nums1的结果集
        int[] res=new int[nums1.length];
        //用来实现单调栈
        Stack<Integer> stack=new Stack<>();
        //将元素倒着放入栈中，目的是用于正着弹出，
        for(int i=nums2.length-1;i>=0;i--){
            //将元素和对应的索引存入map中
            map.put(nums2[i],i);
            //判断栈顶的元素是否小于当前i位置元素（栈顶保存大于i位置的第一个元素），如果小于将他移除,类似于高个看底个子
            //条件是栈不为空且栈顶的元素小于当前位置的元素
            while(!stack.isEmpty()&&nums2[i]>=stack.peek()){
                stack.pop();
            }
            //设置结构果集
            allRes[i]=stack.isEmpty()?-1:stack.peek();
            //将当前i元素压入栈中
            stack.push(nums2[i]);
        }
        //在所有的结果集中，找到他的所要的子集
        for(int i=0;i<nums1.length;i++){
            res[i]=allRes[map.get(nums1[i])];
        }
        return res;
    }
}
```

