## 为什么要复杂度分析？ 



1. 测试结果非常依赖环境。

   在不同的机器，不同的环境下测试的结果是不相同的，比如在一台机器中，a代码执行的速度比b代码块，等我们换台电脑，会有截然不同的结果。

2. 测试结果受数据规模的影响。

   由于存在极端的情况，会对实验的数据有一定的影响。

   ## O的理解

   

   ​      大O时间复杂度实际上并不代表代码真正的执行时间，他只是表示代码时间随数据规模增长的变化趋势，所以，也被称为渐进时间复杂度。简称时间复杂度。

   ​		从计算机执行代码来看，每一行代码都执行着类似的操作，读数据-运算-处理数据，所以我们可以大概的设计算机处理一行代码的时间为1TIME，就以下代码进行分析。

   ```
   int n=100;
           int sum=0;
           for (int i = 0; i <100; i++) {
               sum+=i;
           }
   ```

   在这段代码中，代码执行的时间为T(n)=(100*2+1) * TIME

   ```java
    int sum=0;
           for (int i = 0; i <n ; i++) {
               sum+=i;
           }
       }
   ```

   就这段代码，代码执行的时间为T(n)=(1+2n)*TIME

   细心的你可能会疑惑，这两段代码存在着细微的差别，在上面的那段代码中，那个循环执行了100次，他是常量级的？而下面的那个换成一个变量就变成n呢？

   这就是对时间复杂度概念进行理解，时间复杂度表示的是算法的执行效率与数据规模变化增长的变化趋势。所以常量无论多大，我们都可以忽略掉。即便这段代码执行了上万次，他始终是一个常量级的。

   通过上面的例子，我们就可以总结进行总结。

   ​                          											**T(n)=O(f(n))**

   其中T(n)表示执行代码所用的时间，n表示数据规模的大小，f(n)表示代码执行的总次数。我们将他设成f(n),公式中的O，表示代码执行时间T(n)与f(n)成正比。所以上面的两个例子，可以分别表示为T(n)=O(100*       2+1)与T(n)=O(1+2n),当n很大时，公式中的常量、低阶、系数并不会左右增长趋势，所以都可以忽略，我们只要记录最大的量级就可以了。T(n)=O(100*2+1)可以表示为T(n)=O(100 * 2 +1）* n<sup>0</sup>=O(1),同理第二个例子T(n)=O(n).

   ## 如何进行时间复杂度的分析

   

   #### 1.只关注循环执行次数最多的那一段代码

   ​		在刚才说到O这种时间复杂度方法只是表示一种变化趋势。我们通常会忽视其中的低阶、常量、系数。所以我们只需要关注循环执行次数最多的那一段代码就好了。

   #### 2.加法法则：总复杂度等于量级最大的那段代码的复杂度

   - 复杂度相差数量级的情况

     例如，一个程序中，拥有两个循环，第一个复杂度为O(n),第二个为O(n<sup>2</sup>),则该程序的时间复杂度为O(n).

     公式为： T(n)= O(n)+O(n<sup>2</sup>)=max(O(n),O(n<sup>2</sup>))

   - 复杂度在同一数量级的情况

     例如，一个程序中，拥有两个循环，第一个复杂度为O(n),第二个为O(m),则该程序的时间复杂度为O(n+m).

     公式为： T(n)= O(n)+O(m)=max(O(m+n)

     #### 乘法法则：嵌套代码的复杂度等于其嵌套内外代码复杂度的乘积

     比如，多层循环， 复杂度的计算公式T1(m)*T2(n)=O(f(m) * f(n))

## 常用的复杂度量级 

常见的复杂度的量级可以分为：多项式量级和非多项式量级。

- 非多项式量级只有两个：O(2<sup>n</sup>)和O(n!)

  当数据规模急剧的增加，求解问题的执行时间就会无限的增加。所以非多项式级的时间复杂度其实是非常的低效。

- 多项式式量级

  1. **常量阶O(1)**

     只要代码中不存在循环语句，递归语句，即使有千千万万的语句，其时间复杂度也是O(1)

  2. **对数阶O(logn)**

  3. **线性阶O(n)**

  4. **线性对数阶和O(nlogn)**

  5.**平方阶:O(n<sup>2</sup>),立方阶:O(n<sup>3</sup>)  ** …… 

  在我们高中学过这几个函数的变化趋势，时间复杂度的大小对比：O(n<sup>2</sup>)>O(nlogn)>O(n)>O(logn)>O(1)

