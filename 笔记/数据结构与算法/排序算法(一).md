###  如何分析一个排序算法？

要从一下几个方面讨论。

**1.最好，最坏，平均时间复杂度。**

- 在有的排序算法中，这三个的数据可能是不相同的 。所以我们要加以区分。
- 受所排序数据的影响大，在被排序的数据中，有的数据接近有序，有的数据是完全无序的，不同的数据最终导致算法排序的时间复杂度是不相同的。

**2.时间复杂度的常系数，常数，低阶。**

在前面讲O的含义时，说到O只是时间随数据规模变化的一个趋势。当数据量足够大的时候，我们可以忽略其中的常数项，以及低阶项。但是我们平时的数据规模很小的时候，我们就不可以忽略掉其中的系数以及常数项。	

**3.内存消耗。**

我们是通过时间复杂度和衡量一个程序的好坏。当我们分析算法时，当两个算法的时间复杂度相同时，我们可以通过空间复杂度来比较两个算法。

**4.比较和交换的次数。**

在排序算法中有许多是基于比较来实现的。基于比较的算法在执行的时候 ，一般都会执行两步操作：1.比较。2.交换。所以在衡量一个算法的时候，将该元素考进去。

**5.稳定性**

稳定性：在排序前后相同的数据的前后位置是否发生改变，如果发改变，则该算法是不稳定的。在我们学习的时候，是通过整型数组作为例子。所以数据的前后是无法识别的，但在实际的开发时候，我们进行排序的数据不是简单的整型数据。可能是对对象进行排序。随意稳定性也是一个很重要的指标。

### 经典的排序算法

#### 1.冒泡排序

冒泡排序：通过相邻两元素比较，交换位置实现排序。

下面就通过例子进行说明

假设给一组数据为[4,3,1,2]，将该数据从小到大进行排序。

第一轮的冒泡

| 4   3   1   2(原始数据) |
| :---------------------: |
| 3   4   1   2(3和4交换) |
| 3   1   4   2(1和4交换) |
| 3   1   2   4(2和4交换) |

上面就是经过一轮冒泡排序后的结果。将4移到最后的位置，下一趟冒泡的时候，只用排序前三个元素。

冒泡排序的实现过程

| 原始数据 | 4  3  2   1     |
| -------- | --------------- |
| 第一趟   | 3  1  2   **4** |
| 第二趟   | 1  2  3   4     |

**冒泡排序的代码实现**

```java
//a表示数组，n表示数组的长度
public void BubbleSort(int[] a,int n)  {
    if(n<=1){
        return;
    }
    for(int i=0;i<n;i++){
        //这个循环表示要进行多少趟冒泡
        for(int j=0;j<n-i-1;j++){
            //这层循环进行数据的交换
            if(a[j]>a[j++]){
                //如果左边的元素大于右边的元素进行交换
                int t=a[j];
                a[j]=a[j+1];
                a[j+1]=t;
            }
      }
    } 
}
```

通过上面的代码实现了一个冒泡排序算法，但是如果我们进行到其中的i(i<n)趟时该数据已经有序，那后面的n-i趟都是多余的，下面就对其进行优化。

代码如下，

```java
//a表示数组，n表示数组的长度
public void BubbleSort(int[] a,int n)  {
    if(n<=1){
        return;
    }
    for(int i=0;i<n;i++){
        //这个循环表示要进行多少趟冒泡
        //使用flag进行标记
        blooean flag=false;
        for(int j=0;j<n-i-1;j++){
            //这层循环进行数据的交换
            if(a[j]>a[j++]){
                //如果左边的元素大于右边的元素进行交换
                int t=a[j];
                a[j]=a[j+1];
                a[j+1]=t;
                flag=true;
            }
      }
        //如果没用交换退出
        if(!flag){return;}
    } 
}
```

上面讲述了冒泡排序的实现，下面就冒泡排序的几个性能说明。

**1.最好时间复杂度为O(n),即数组是有序的只进行一趟冒泡排序。最坏时间复杂度为O(n<sup>2</sup>),**

**平均时间复杂度为O(n<sup>2</sup>)**。

**2.冒泡排序是稳定的。在冒泡排序中遇到两个相同的元素的时候，位置并不发生改变，所以是稳定的。**

下面通过有序度以及无序度的概念对冒泡排序的平均时间复杂度进行分析。

先引出几个概念

**有序度：数组中具有有序数据对的个数。**举个例子，一组数据为[2,3,1,4]，其中有序的数对为[2,3]、[2,4]、[3,4]、[1,4],所以该数据的有序度为4。

**满有序度：当一组数据为完全有序时的有序度(从小到大排序)。**举个例子，一组数据为[1,2,3,4]，其中有序的数对为[1,2]、[2,3]、[2,4]、[3,4]、[1,4]、[1,3],所以该数据的有序度为6。我们可以很轻易的得出它的通用公式为**满有序度=n*(n-1)/2**

**逆序度：与有序度的概念时相反的。**

上面三者的关系：**满有序度=逆序度+有序度**

下面举个例子：一组数据为[2,3,1,4],再进行冒泡排序的时候，每一次都执行两步操作，比较和交换，当我们每进行一次交换的时候，他的有序度就会增加1，不管我们如何去改进算法，他的交换的次数是一定的。

当包含n元素的数据，最坏的情况，初始状态有序度为零，要进行`n*(n-1)/2`次交换。当数据有序的时候，该数据的有序度为`n*(n-1)/2`，不需要交换，们取它的中间值为`n*(n-1)/4`，所以可以得到冒泡排序的空间复杂度为`O(n<sup>2</sup>)`.

#### 插入排序

当我们向一个有序的数组中插入新的元素时，我们通过将这个元素与数组中的所用元素从头逐个比较找到合适的位置插入到里面。插入排序同时应用这个思想。

将数据分成有序区和无序区，从无序区中取向有序区中插入元素，直到无序区中的元素为空。

```java
   public   int[]  fromStartToEnd(int[] arr){
   for(int i=0;i<arr.length;i++){
        //标记要比较的元素
   		int temp = arr[i];
   		int j=i;
       //从左向右逐个比较
   		while(j>0 && temp<arr[j-1]){
   		arr[j]=arr[j-1];
   		j--;
   		}
       	//将标记的元素插入到数据中
   		if(j!=i){
   		a[j]=temp;
   		}
   }
       return arr;
   }
```

##### 插入排序的总结

1. **插入排序是一种原地排序,在排序的过程中，不需要额外的内存空间。**
2. **插入排序是一种稳定的排序，我们可以选择后面出现的元素插入到前面出现的元素后面，可以保持原有的顺序。**
3. **插入排序的最好时间复杂度是O(n)，最坏时间复杂度为O(n<sup>2</sup>),平均时间复杂度为O(n<sup>2</sup>)**。

#### 选择排序

##### 思想：选择排序类似于插入排序将元素分为已排序区间和未排序区间。比较交换的过程是进行标记其中的最大值(或最小值)，进行交换。

**代码实现**

```java
public   int[] selectionSort(int[] arr){
  for (int i = 0; i < arr.length; i++) {
		//标记最小的位置
		int min=i;
		for (int j = i+1; j < arr.length ; j++) {
			//找到最小的值
		if(arr[j]<arr[min]) {
		min=j;
		}
		}
		int tmp=arr[i];
		arr[i]=arr[min];
		arr[min]=temp;
}
    return arr;
}
```

##### 选择排序总结

1. **选择排序的最好时间复杂度是O(n<sup>2</sup>)，最坏时间复杂度为O(n<sup>2</sup>),平均时间复杂度为O(n<sup>2</sup>)**。
2. **选择排序不是一种稳定的排序，在交换的过程中元素的前后会发生改变。**
3. **插入排序是原地排序。**

#### 三种原地排序的总结

|          | 是否稳定 | 最好时间复杂度   | 最坏时间复杂度   | 平均时间复杂度   |
| :------- | -------- | ---------------- | ---------------- | ---------------- |
| 冒泡排序 | 是       | O(n)             | O(n<sup>2</sup>) | O(n<sup>2</sup>) |
| 选择排序 | 否       | O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(n<sup>2</sup>) |
| 插入排序 | 是       | O(n)             | O(n<sup>2</sup>) | O(n<sup>2</sup>) |

